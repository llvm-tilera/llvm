//===- Tile64Schedule.td - Tile64 Scheduling Definitions ---*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
// 
//===----------------------------------------------------------------------===//
//
//                               Tile64 Backend
//
// Author: David Juhasz
// E-mail: juhda@caesar.elte.hu
// Institute: Dept. of Programming Languages and Compilers, ELTE IK, Hungary
//
// The research is supported by the European Union and co-financed by the
// European Social Fund (grant agreement no. TAMOP
// 4.2.1./B-09/1/KMR-2010-0003).
//
//===----------------------------------------------------------------------===//


//
//Bundle-approach:
//---------------
//NOTE: Eventually not used in this form for the autogenerated DFAPacketizer,
//see pipeline-approach.
//
//There are two types of bundles: two-wide (X) and three-wide (Y). X-bundles
//can consists of X0 and X1 issues, and Y-bundles of Y0, Y1 and Y2 issues.
//Hence, there are five virtual pipeline: X0, X1, Y0, Y1, Y2.
//
//The following table summarizes the different types of instructions according
//to their schedulability:
//
//    |==========|====|====|====|====|====|
//    |          | X0 | X1 | Y0 | Y1 | Y2 |
//    |==========|====|====|====|====|====|
//    |  ArS     | +  | +  | +  | +  |    |
//    |----------|----|----|----|----|----|
//    |  ArL     | +  | +  |    |    |    |
//    |----------|----|----|----|----|----|
//    |  BmS     | +  |    | +  |    |    |
//    |----------|----|----|----|----|----|
//    |  BmL     | +  |    |    |    |    |
//    |----------|----|----|----|----|----|
//    |  Ctr     |    | +  |    |    |    |
//    |----------|----|----|----|----|----|
//    |  Mem     |    | +  |    |    | +  |
//    |----------|----|----|----|----|----|
//    |  Ill     |    | +  |    | +  |    |
//    |==========|====|====|====|====|====|
//
//
//  Ar  - Arithmetic, Compare (ArS), Logical except mvnz and mvz and tblidx,
//        NOP (ArS), SIMD except abs diff instructions (ArL)
//  Bm  - Bit Manipulation, mvnz and mvz and tblidx from logical, Multiply,
//        abs diff from SIMD (BmL)
//  Ctr - Control, Memory w/ immediate (TilePro) and tns, Memory Maintenance,
//        System except ill
//  Mem - Memory except tns and TilePro only instructions
//  Ill - ill from System
//
//
//Pipeline-approach:
//-----------------
//NOTE: Pipeline-approach described below is a sensible way to handle VLIW
//packetizing, and this two-level approach was implemented for a while.
//However, the two bunch of types are mostly redundant, unnecessary and hardly
//maintainable, so a synthesis of the two approaches is implemented after all.
//(See Synthesized approach.)
//
//Initial implementation of packetizer would use the concept of bundles
//summarized above, but the infrastructure of LLVM DFAPacketizer (as of 3.2svn)
//could handle only one type of bundles, so only X-bundles could be used.
//Moreover, the units in bundles (Xs and Ys) are only virtual units. The
//processor engine actually have three pipelines which are to be defined as
//FuncUnits here.
//
//However, grouping instructions according bundle-units are also neccessary to
//create valid bundles. It's just an other layer of packetizing. Firstly,
//DFAPacketizer checks if there is a physical unit, a pipeline which can
//execute the instruction with respect to the instructions already in the
//actual packet. If so, we need to check whether the new packet could be
//legally coded into a bundle or not. This testing is to be performed by the
//target-specific VLIW packetizer.
//
//
//The following table summarizes the different types of instructions and their
//schedulability to pipelines according to UG101 Section 2.1.1.1.
//
//    |=========|====|====|====|  types used
//    |         | P0 | P1 | P2 |  to schedule
//    |=========|====|====|====|  ============
//    |  alu    | +  | +  |    |    -  ALU
//    |---------|----|----|----|
//    |  bit    | +  |    |    |    -
//    |---------|----|----|----|    |
//    |  sel    | +  |    |    |    |
//    |---------|----|----|----|    |- AAL (advanced arithmetical/logical)
//    |  mul    | +  |    |    |    |
//    |---------|----|----|----|    |
//    |  fma    | +  |    |    |    -
//    |---------|----|----|----|
//    |  spr    |    | +  |    |    -
//    |---------|----|----|----|    |- CTR
//    |  cfi    |    | +  |    |    -
//    |---------|----|----|----|
//    |  mem    |    |    | +  |    -  MEM
//    |=========|====|====|====|
//
//  Used abbreviations:
//   * alu ~ ALU operations
//   * bit ~ bit manipulation operations
//   * sel ~ select operations (mvnz, mvz)
//   * mul ~ multiply operations
//   * fma ~ fused multiply-add operations
//   * spr ~ special purpose register reads and writes
//   * cfi ~ control flow instructions (branches and jumps)
//   * mem ~ load and store instructions and
//           cache and memory maintenance instructions
//
//Having checked executability of instructions according to the above table,
//bundle constraints, i.e. whether X- or Y-bundle should be used and the
//instructions could be coded in that type of bundle, can be tested in a simple
//way when keeping in mind that the instructions can be executed by the
//physical units. Note that checking of bundle-constraints utilizes types
//described for bundle-approach.
//
//If one instruction is already in a packet, then only conflicting instruction
//types are Ctr and Mem, i.e. if the old instruction is Ctr and the new one is
//Mem or the old instruction is Mem and the new one is Ctr, then the new
//instruction cannot be bundled together with the already packed instruction.
//
//If two instructions are already in a packet, then the only conflicting case
//is the one when any of the three instructions (the two already packed and the
//new one) is long, i.e. can be coded only in X-bundles. Long instruction-types
//are ArL, BmL and Ctr.
//
//
//Synthesized approach:
//--------------------
//
//In this synthesized approach we typify instructions using types of
//bundle-approach and map these types to physical pipelines. Additional
//checking of bundle-constraints can be done just the way like in
//pipeline-approach.
//
//Using this method, only one type per instruction has to be maintained rather
//than the two types of pipeline-approach.
//
//Here is the mapping of types introduced for pipeline-approach to the types of
//bundle-approach:
//
//  |=======|============|
//  |  ALU  |  ArS, ArL  |
//  |-------|------------|
//  |  AAL  |  BmS, BmL  |
//  |-------|------------|
//  |  CTR  |  Ctr, Ill  |
//  |-------|------------|
//  |  MEM  |    Mem     |
//  |=======|===/===\====|
//             /     \
//           MeS    MeL
//
//In this approach memory and memory maintenance instructions have to be
//typified into short and long instruction types. Long memory instructions were
//typed as Ctr in bundle-approach, but they occupy pipeline P2 rather than P1
//as Ctr instructions do.
//
//
//And the following table contains the synthesized scheduling informations:
//
//    |==========|====|====|====|
//    |          | P0 | P1 | P2 |
//    |==========|====|====|====|
//    |  ArS     | +  | +  |    |
//    |----------|----|----|----|
//    |  ArL     | +  | +  |    |
//    |----------|----|----|----|
//    |  BmS     | +  |    |    |
//    |----------|----|----|----|
//    |  BmL     | +  |    |    |
//    |----------|----|----|----|
//    |  Ctr     |    | +  |    |
//    |----------|----|----|----|
//    |  MeS     |    |    | +  |
//    |----------|----|----|----|
//    |  MeL     |    |    | +  |
//    |----------|----|----|----|
//    |  Ill     |    | +  |    |
//    |==========|====|====|====|
//
//In this case, checking of bundle constraints must be modified as type Mem is
//substituted with two types MeS and MeL, i.e. when testing against Mem in
//pipeline-approach, now must test against MeS and MeL.
//
//
//**********
//
//  TilePro pipeline latencies can be found in UG101 Table 3-2.
//

// Functional Units

def P0 : FuncUnit;
def P1 : FuncUnit;
def P2 : FuncUnit;

// Itinerary classes

def ArS    : InstrItinClass;
def ArL    : InstrItinClass;
def BmS    : InstrItinClass;
def BmL    : InstrItinClass;
def Ctr    : InstrItinClass;
def MeS    : InstrItinClass;
def MeL    : InstrItinClass;
def Ill    : InstrItinClass;

//For VLIW scheduler. Pseudo instructions are solo instructions for
//VLIW packetizer.
def PSEUDO : InstrItinClass;

// Itineraries

def Tile64Itineraries : ProcessorItineraries<[P0, P1, P2], [], [
  InstrItinData<ArS,    [InstrStage<1, [P0, P1]>]>,
  InstrItinData<ArL,    [InstrStage<1, [P0, P1]>]>,
  InstrItinData<BmS,    [InstrStage<1, [P0]>]>,
  InstrItinData<BmL,    [InstrStage<1, [P0]>]>,
  InstrItinData<Ctr,    [InstrStage<1, [P1]>]>,
  InstrItinData<MeS,    [InstrStage<1, [P2]>]>,
  InstrItinData<MeL,    [InstrStage<1, [P2]>]>,
  InstrItinData<Ill,    [InstrStage<1, [P1]>]>,
  InstrItinData<PSEUDO, [InstrStage<1, [P0, P1, P2]>]>
  ]>;

// Processor itineraries
def Tile64Model : SchedMachineModel {
  // Max issue per cycle == bundle width.
  let IssueWidth = 3;
  let Itineraries = Tile64Itineraries;
}

